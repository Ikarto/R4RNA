% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/additional_tools_mltp.R
\name{isConflictingHelixMltp}
\alias{isConflictingHelixMltp}
\alias{isDuplicatingHelixMltp}
\alias{isOverlappingHelixMltp}
\title{Logical filters of helix by type}
\usage{
isConflictingHelixMltp(helix)

isDuplicatingHelixMltp(helix)

isOverlappingHelixMltp(helix, query)
}
\arguments{
\item{helix}{A helix data table}

\item{query}{For \code{isOverlappingHelixMltp}, a helix data structure against
which \code{helix} will be checked for overlap against.}
}
\description{
Given a helix data frame, checks if helices are conflicting,
duplicating, or overlapping, and returns an array of logicals.
See details for exact definition of the three types of events.
}
\details{
Helices of length greater than 1 are internall expanded into
basepairs of length 1, after which the following conditions are evaluated:
A conflicting basepair is one where at least one of its two positions is used by either end of another basepair.
A duplicating basepair is one where both of its positions are used by both ends of another basepair.
An overlapping basepair is one in helix where both of its
positions are used by both ends of another basepair in the query structure.

In the case of conflicting and duplicating basepairs, for a set of basepairs
that satisfies this condition, the basepair situation highest on the data frame
will be exempt from the condition. i.e. Say 5 basepairs are all duplicates of each
other, the top 1 will return FALSE, while the bottom 4 will return TRUE. This
assumes some significant meaning to the ordering of rows prior to using this function.
This is to be used with which to filter out basepairs that satisfy these conditions,
leaving a set of basepairs free of these events.
}
